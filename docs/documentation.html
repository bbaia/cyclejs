<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">
  <title>Cycle.js - Documentation</title>

  <!-- Flatdoc -->
  <script src='support/vendor/jquery.js'></script>
  <script src='support/vendor/highlight.pack.js'></script>
  <script src='legacy.js'></script>
  <script src='flatdoc.js'></script>

  <!-- Others -->
  <script async src="//static.jsbin.com/js/embed.js"></script>

  <!-- Flatdoc theme -->
  <link href='theme/style.css' rel='stylesheet'>
  <script src='theme/script.js'></script>
  <link href='support/vendor/highlight-github-gist.css' rel='stylesheet'>

  <!-- Meta -->
  <meta content="Cycle.js - Documentation" property="og:title">
  <meta content="A functional and reactive JavaScript framework for predictable code" name="description">

  <!-- Content -->
  <script id="markdown" type="text/markdown" src="index.html">
# Getting started

## Consider create-cycle-app

The quickest way to create a new project with Cycle.js is by using [create-cycle-app](https://github.com/cyclejs-community/create-cycle-app), giving you the choice between ES6 or TypeScript, Browserify or Webpack.

> [create-cycle-app >](https://github.com/cyclejs-community/create-cycle-app)

First install Create Cycle App globally in your system.

```bash
npm install --global create-cycle-app
```

Then, this command will create a project called *my-awesome-app* (or another name of your choice) with Cycle *Run* and Cycle *DOM*.

```
create-cycle-app my-awesome-app
```

## Install from npm

If you want to have more control over your project, the recommended channel for downloading Cycle.js as a package is through [npm](http://npmjs.org/).

Create a new directory and run this npm command inside that directory. This installs [xstream](http://staltz.com/xstream), Cycle *Run*, and Cycle *DOM*.

```
npm install xstream @cycle/run @cycle/dom
```

Packages *xstream* and *Run* are the minimum required API to work with Cycle.js. The *Run* package includes a single function `run()`, and Cycle *DOM* is the standard DOM Driver providing a way to interface with the DOM. You can also use Cycle.js with other stream libraries like RxJS or Most.js.

> We recommend xstream if you don't know what to choose.

```
npm install xstream @cycle/run
```

> [RxJS](http://reactivex.io/rxjs)

```
npm install rxjs @cycle/rxjs-run
```

> [Most.js](https://github.com/cujojs/most)

```
npm install most @cycle/most-run
```

Note: packages of the type `@org/package` are [npm scoped packages](https://docs.npmjs.com/getting-started/scoped-packages), supported if your npm installation is version 2.11 or higher. Check your npm version with `npm --version` and upgrade in order to install Cycle.js.

In case you are not dealing with a DOM-interfacing web application, you can omit `@cycle/dom` when installing.

## Coding

We recommend the use of a bundling tool such as [browserify](http://browserify.org/) or [webpack](http://webpack.github.io/), in combination with ES6 (a.k.a. ES2015) through a transpiler (e.g. [Babel](http://babeljs.io/) or [TypeScript](http://typescriptlang.org/)). Most of the code examples in this documentation assume some basic familiarity with ES6.

### Import libraries

Once your build system is set up, start writing your main JavaScript source file like this, to import the libraries. The second line imports the function `run(main, drivers)`, where `main` is the entry point for our whole application, and `drivers` is a record of driver functions labeled by some name.

```js
import xs from 'xstream';
import {run} from '@cycle/run';
import {makeDOMDriver} from '@cycle/dom';

// ...
```

### Create `main` and `drivers`

Then, write a `main` function, for now with empty contents. `makeDOMDriver(container)` from Cycle *DOM* returns a driver function to interact with the DOM. This function is registered under the key `DOM` in the `drivers` object.

```js
function main() {
  // ...
}

const drivers = {
  DOM: makeDOMDriver('#app')
};
```

Then, call `run()` to connect the main function with the drivers.

```js
run(main, drivers);
```

### Send messages from `main`

We have filled the `main()` function with some code: returns an object `sinks` which has an `xstream` stream defined under the name `DOM`. This indicates `main()` is sending the stream as messages to the DOM driver. Sinks are outgoing messages. The stream emits Virtual DOM `<h1>` elements displaying `${i} seconds elapsed` changing over time every second, where `${i}` is replaced by `0`, `1`, `2`, etc.

```js
function main() {
  const sinks = {
    DOM: xs.periodic(1000).map(i =>
      h1('' + i + ' seconds elapsed')
    )
  };
  return sinks;
}
```

Also, remember to import `h1` from Cycle DOM.

> In the beginning of the file:

```js
import {makeDOMDriver, h1} from '@cycle/dom';
```

### Catch messages into `main`

Function `main()` now takes `sources` as input. Just like the output `sinks`, the input `sources` follow the same structure: an object containing `DOM` as a property. Sources are incoming messages. `sources.DOM` is an object with a queryable API to get streams. Use `sources.DOM.select(selector).events(eventType)` to get a stream of `eventType` DOM events happening on the element(s) specified by `selector`. This `main()` function takes the stream of `click` events happening on `input` elements, and maps those toggling events to Virtual DOM elements displaying a togglable checkbox.

```js
function main(sources) {
  const sinks = {
    DOM: sources.DOM.select('input').events('click')
      .map(ev => ev.target.checked)
      .startWith(false)
      .map(toggled =>
        div([
          input({attrs: {type: 'checkbox'}}), 'Toggle me',
          p(toggled ? 'ON' : 'off')
        ])
      )
  };
  return sinks;
}
```

Remember to import new element types from Cycle DOM.

> In the beginning of the file:

```js
import {makeDOMDriver, div, input, p} from '@cycle/dom';
```

### Consider JSX

We used the `div()`, `input()`, `p()` helper functions to create virtual DOM elements for the respective `<div>`, `<input>`, `<p>` DOM elements, but you can also use JSX with Babel. The following only works if you are building with Babel:

(1) Install the npm packages [babel-plugin-transform-react-jsx](http://babeljs.io/docs/plugins/transform-react-jsx/) and [snabbdom-jsx](https://www.npmjs.com/package/snabbdom-jsx).

```
npm install --save babel-plugin-transform-react-jsx snabbdom-jsx
```

(2) Specify a pragma for JSX in the `.babelrc` file.

> .babelrc

```json
{
  "presets": [
    "es2015"
  ],
  "plugins": [
    "syntax-jsx",
    ["transform-react-jsx", {"pragma": "html"}]
  ]
}
```

(3) Import Snabbdom JSX.

> main.js

```js
import xs from 'xstream';
import {run} from '@cycle/xstream-run';
import {makeDOMDriver} from '@cycle/dom';
import {html} from 'snabbdom-jsx';
```

(4) Use JSX as return values.

This example portrays the most common problem-solving pattern in Cycle.js: formulate the computer's behavior as a function of streams: continuously listen to source messages from drivers and continuously provide sinks messages (in our case, Virtual DOM elements) to the drivers. Read the next chapter to get familiar with this pattern.

```jsx
function main(sources) {
  const sinks = {
    DOM: sources.DOM.select('input').events('click')
      .map(ev => ev.target.checked)
      .startWith(false)
      .map(toggled =>
        <div>
          <input type="checkbox" /> Toggle me
          <p>{toggled ? 'ON' : 'off'}</p>
        </div>
      )
  };
  return sinks;
}
```

## Install without npm

In the rare occasion you need Cycle.js scripts as standalone JavaScript files, you can download them from [unpkg](https://unpkg.com) directly into your HTML file:

- Latest Cycle.js [xstream run](https://unpkg.com/@cycle/xstream-run/dist/cycle.js)
- Latest Cycle.js [most.js run](https://unpkg.com/@cycle/most-run/dist/cycle-most-run.js)
- Latest Cycle.js [RxJS v5 run](https://unpkg.com/@cycle/rxjs-run/dist/cycle.js)
- Latest Cycle.js [RxJS v4 run](https://unpkg.com/@cycle/rx-run/dist/cycle.js)
- Latest Cycle.js [DOM](https://unpkg.com/@cycle/dom/dist/cycle-dom.js)
- Latest Cycle.js [HTTP](https://unpkg.com/@cycle/http/dist/cycle-http-driver.js)
- Latest Cycle.js [Isolate](https://unpkg.com/@cycle/isolate/dist/cycle-isolate.js)

# Dialogue abstraction

## Human-Computer Interaction

Cycle.js introduces a [message passing](https://en.wikipedia.org/wiki/Message_passing) architecture to model [Human-Computer Interaction (HCI)](https://en.wikipedia.org/wiki/Human%E2%80%93computer_interaction). While most Frontend frameworks focus on Graphical User Interfaces on the DOM, Cycle.js is more holistic and suitable when you need to create any kind of Human-Computer Interaction. This chapter provides some insights into how the Cycle.js architecture was devised. HCI is a two-way process: both sides listen and speak.

![simple human computer interaction](img/simple-human-computer.svg)

The computer usually "speaks" visual information through a screen, which the human can "listen". Through different devices, the computer can reach different human senses. The human, on the other hand, often "speaks" commands to the computer through its hand, manipulating a mouse or touching a screen.

Human-Computer Interaction is a dialogue: an ongoing exchange of messages between both sides.

Both parties are able to "listen" to each other, and utter messages through their devices. In other words, we can say the human and the computer are mutually observed, or simply having a dialogue. The reason why we point out "mutual observation" is because it is related to Reactive Programming and will affect how we model this system.

> ### Similarity with Haskell 1.0?
>
> This same dialogue concept can be found in [Haskell 1.0 Stream-based I/O](https://www.haskell.org/definition/haskell-report-1.0.ps.gz), where `type Dialogue = [Response] -> [Request]` is the model of interaction with the Operating System. `[Response]` is a stream (lazy potentially-infinite list, to be more accurate) of messages from the OS, and `[Request]` is a stream of messages to the OS.
>
> Cycle.js' abstraction was discovered independently from Haskell's Stream I/O. We try to take some inspiration from Haskell's `Dialogue` whenever convenient, but there are a few conceptual differences. Not all problems with Haskell's `Dialogue` exist in Cycle.js or matter to Cycle.js users, and vice-versa. This is due to different execution environment assumptions and different design decisions on modelling event streams. If you want more details on this topic, the following GOTO talk is recommended, centered around the history and theory behind Cycle.js:

<p>
  <iframe width="100%" height="360" src="https://www.youtube.com/embed/Tkjg179M-Nc" frameborder="0" allowfullscreen></iframe>
</p>

## Senses/actuators as I/O

The computer is made of devices to interact with the human. *Output* devices present information to the human, and *input* devices detect actions from the human. The human possesses *actuators* and *senses*, which are connected to the computer's *input* and *output* devices, respectively.

![actuators senses I/O](img/actuators-senses-input-output.svg)

The *inputs* and *outputs* of the computer suggest the computer's role in HCI can be expressed as a function. We do not yet know what `inputDevices` and `outputDevices` should be in JavaScript, but for now try to appreciate the elegance of `computer()` as a pure function.

```javascript
function computer(inputDevices) {
  // define the behavior of `outputDevices` somehow
  return outputDevices;
}
```

Refactoring and architecture can be just a matter of choosing the right composition of functions to make up `computer()`.

When talking about inputs, outputs, senses, and actuators, it becomes difficult to describe the difference between senses and inputs, other than the former is often associated with humans, and the latter with computers. From the computer's perspective, a microphone and its drivers are how the computer is able to *sense* auditory information. In essence, when we ignore the nature of the human body and the physics of computing machines, the human and the computer are both simply agents with senses and actuators.

```javascript
function computer(senses) {
  // define the behavior of `actuators` somehow
  return actuators;
}
```

The agents in this interaction are now **symmetric**: the actuator of one is connected to the senses of the other, and conversely.

![actuators senses](img/actuators-senses.svg)

The diagram above is an [anthropomorphism](https://en.wikipedia.org/wiki/Anthropomorphism) of the computer. If we take the opposite approach of objectifying humans as machines, then both human and computer would be functions with inputs and outputs.

![HCI Input Output](img/hci-inputs-outputs.svg)

Which suggests the human would be a function from its senses to its actuators.

```javascript
function human(senses) {
  // define the behavior of `actuators` somehow
  return actuators;
}
```

> Watch Andre Staltz's talk on **What if the user was a function?** which addresses the same topics as this chapter does.

<p>
  <iframe width="100%" height="360" src="https://www.youtube.com/embed/1zj7M1LnJV4" frameborder="0" allowfullscreen></iframe>
</p>

While these abstractions seem to be natural choices for user interfaces, many questions still remain:

- What are the types of `senses` and `actuators`?
- When is the `human()` function called?
- When is the `computer()` function called?
- If the output of one is the input of the other, how do we solve the circular dependency `y = human(x)` and `x = computer(y)`?

These are questions that drive the core architecture of Cycle.js, but to understand our solution, we first need to understand reactive streams: our building block for everything in Cycle.js.

# Streams

## Reactive Programming

Reactivity is an important aspect in Cycle.js, and part of the core principles that led to the creation of this framework. There is a lot of confusion surrounding what Reactive means, so let's focus on that topic for a while.

Say you have a module Foo and a module Bar. A *module* can be considered to be an object of an [OOP](https://en.wikipedia.org/wiki/Object-oriented_programming) class, or any other mechanism of encapsulating state. Let's assume all code lives in some module. Here we have an arrow from Foo to Bar, indicating that Foo somehow affects state living inside Bar.

![modules foo bar](img/modules-foo-bar.svg)

A practical example of such arrow would be: *whenever Foo does a network request, increment a counter in Bar*. If all code lives in some module, **where does this arrow live?** Where is it defined? The typical choice would be to write code inside Foo which calls a method in Bar to increment the counter.

> Inside module Foo

```javascript
function onNetworkRequest() {
  // ...
  Bar.incrementCounter();
  // ...
}
```

Because Foo owns the relationship "*when network request happens, increment counter in Bar*", we say the arrow lives at the arrow tail, i.e., Foo.

![passive foo bar](img/passive-foo-bar.svg)

Bar is **passive**: it allows other modules to change its state. Foo is proactive: it is responsible for making Bar's state function correctly. The passive module is unaware of the existence of the arrow which affects it.

The alternative to this approach inverts the ownership of the arrow, without inverting the arrow's direction.

![passive foo bar](img/reactive-foo-bar.svg)

With this approach, Bar listens to an event happening in Foo, and manages its own state when that event happens. Bar is **reactive**: it is fully responsible for managing its own state by reacting to external events. Foo, on the other hand, is unaware of the existence of the arrow originating from its network request event.

> Inside module Bar

```javascript
Foo.addOnNetworkRequestListener(() => {
  self.incrementCounter(); // self is Bar
});
```

What is the benefit of this approach? It is Inversion of Control, mainly because Bar is responsible for itself. Plus, we can hide Bar's `incrementCounter()` as a private function. In the passive case, it was required to have `incrementCounter()` public, which means we are exposing Bar's internal state management outwards. It also means if we want to discover how Bar's counter works, we need to find all usages of `incrementCounter()` in the codebase. In this regard, Reactive and Passive seem to be dual to each other.

|                       | Passive                 | Reactive      |
|-----------------------|-------------------------|---------------|
| How does Bar work?    | *Find usages*           | Look inside   |

On the other hand, when applying the Reactive pattern, if you want to discover which modules are affected by an event in a Listenable module, you must find all usages of that event.

|                             | Proactive               | Listenable    |
|-----------------------------|-------------------------|---------------|
| Which modules are affected? | Look inside             | *Find Usages* |

Passive/Proactive programming has been the default way of working for most programmers in imperative languages. Sometimes the Reactive pattern is used, but sporadically. The selling point for widespread Reactive programming is to build self-responsible modules which focus on their own functionality rather than changing external state. This leads to Separation of Concerns.

The challenge with Reactive programming is this paradigm shift where we attempt to choose the Reactive/Listenable approach by default, before considering Passive/Proactive. After rewiring your brain to think Reactive-first, the learning curve flattens and most tasks become straightforward, especially when using a Reactive library like RxJS or *xstream*.

## What is a Stream?

Reactive programming can be implemented with: event listeners, [RxJS](http://reactivex.io/rxjs), [Bacon.js](http://baconjs.github.io/), [Kefir](https://rpominov.github.io/kefir/), [most.js](https://github.com/cujojs/most), [EventEmitter](https://nodejs.org/api/events.html), [Actors](https://en.wikipedia.org/wiki/Actor_model), and more. Even [spreadsheets](https://en.wikipedia.org/wiki/Reactive_programming) utilize the same idea of the cell formula defined at the arrow head. The above definition of Reactive programming is not limited to streams, and does not conflict with previous definitions of Reactive Programming. Cycle.js supports multiple stream libraries, such as [RxJS v4](https://github.com/Reactive-Extensions/RxJS), [RxJS v5](http://reactivex.io/rxjs), [xstream](http://staltz.com/xstream), and [most.js](https://github.com/cujojs/most), but by default we choose *xstream* because it was custom built for Cycle.js.

In short, a *Stream* in *xstream* is an event stream which can emit zero or more events, and may or may not finish. If it finishes, then it does so by either emitting an error or a special "complete" event.

> Stream contract

```
(next)* (complete|error){0,1}
```

As an example, here is a typical Stream: it emits some events, then it eventually completes.

![completed stream](img/completed-stream.svg)

Streams can be listened to, just like EventEmitters and DOM events can. Notice there are 3 handlers: one for events, one for errors, and one for "complete".

```javascript
myStream.addListener({
  next: function handleNextEvent(event) {
    // do something with `event`
  },
  error: function handleError(error) {
    // do something with `error`
  },
  complete: function handleCompleted() {
    // do something when it completes
  },
});
```

*xstream* Streams become very useful when you transform them with the so-called *operators*, pure functions that create new Streams on top of existing ones. Given a Stream of click events, you can easily make a Stream of the number of times the user clicked.

> Operators

```javascript
const clickCountStream = clickStream
  // each click represents "1 amount"
  .mapTo(1)
  // sum all events `1` over time, starting from 0
  .fold((count, x) => count + x, 0);
```

[Succinctness is Power](http://www.paulgraham.com/power.html), and *xstream* operators demonstrate that you can achieve a lot with a few well-placed operators. With only about [26 operators](https://github.com/staltz/xstream#methods-and-operators), you can build almost all programming patterns needed in a Cycle.js app.

Knowing the basics of reactive streams programming is a prerequisite to getting work done with Cycle.js. Instead of teaching RxJS or *xstream* on this site, we recommend a few great learning resources, in case you need to learn more. *xstream* is similar to *RxJS*, so these resources apply:

- [The introduction to Reactive Programming you've been missing](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754): a thorough introduction to RxJS by Cycle.js author Andre Staltz.
- [Introduction to Rx](http://introtorx.com/): an online book focused on Rx.NET, but most concepts map directly to RxJS.
- [ReactiveX.io](http://reactivex.io/): official cross-language documentation site for ReactiveX.
- [Learn Rx](http://reactivex.io/learnrx/): an interactive tutorial with arrays and Observables, by Jafar Husain.
- [RxJS lessons at Egghead.io](https://egghead.io/technologies/rx)
- [RxJS GitBook](http://xgrommx.github.io/rx-book/)
- [RxMarbles](http://rxmarbles.com/): interactive diagrams of RxJS operators, built with Cycle.js.
- [Async JavaScript at Netflix](https://www.youtube.com/watch?v=XRYN2xt11Ek): video of Jafar Husain introducing RxJS.

## Streams in Cycle.js

Now we are able to explain the types of `senses` and `actuators`, and what it means for the computer and human to be "mutually observed."

In the simplest case, the computer generates pixels on the screen, and the human generates mouse and keyboard events. The computer observes these user inputs and the human observes the screen state generated by the computer. Notice that we can model each of these as *Streams*:

- Computer's output: a stream of screen images.
- Human's output: a stream of mouse/keyboard events.

The `computer()` function takes the human's output as its input, and vice versa. They mutually observe each other's output. In JavaScript, we could write the computer function as a simple chain of *xstream* transformations on the input stream.

```javascript
function computer(userEventsStream) {
  return userEventsStream
    .map(event => /* ... */)
    .filter(someCondition)
    .map(transformItToScreenPixels)
    .flatten();
}
```

While doing the same with the `human()` function would be elegant, we cannot do that as a simple chain of operators because we need to leave the JavaScript environment and affect the external world. While conceptually the `human()` function can exist, in practice, we need to use *driver* functions in order to reach the external world.

[Drivers](/drivers.html) are adapters to the external world, and each driver represents one aspect of external effects. For instance, the DOM Driver takes a "screen" Stream generated by the computer, and returns Streams of mouse and keyboard events. In between, the DOM Driver function produces "*write*" side effects to render elements on the DOM, and catches "*read*" side effects to detect user interaction. This way, the DOM Driver function can act on behalf of the user. The name "driver" is based off Operating System drivers, which have a similar kind of role: to create a bridge between devices and your software.

Joining both parts, we have a computer function, often called `main()`, and a driver function, where the output of one is the input of the other.

```
y = domDriver(x)
x = main(y)
```

The circular dependency above cannot be solved if `=` means assignment, because that would be equivalent to the command `x = g(f(x))`, and `x` is undefined on the right-hand side.

This is where Cycle.js comes in: you only need to specify `main()` and `domDriver()`, and give it to the Cycle.js `run()` command which connects them circularly.

```javascript
function main(sources) {
  const sinks = {
    DOM: // transform sources.DOM through
         // a series of xstream operators
  };
  return sinks;
}

const drivers = {
  DOM: makeDOMDriver('#app') // a Cycle.js helper factory
};

run(main, drivers); // solve the circular dependency
```

This is how the name "*Cycle.js*" came to be. It is a framework that solves the cyclic dependency of Observables which emerge during dialogues (mutual observations) between the Human and the Computer.

# Basic examples

## Common structure

Cycle.js apps will always include at least three important components: `main()`, **drivers**, and `run()`. In `main()`, we receive messages from drivers (sources, the input to `main`) and we send messages to drivers (sinks, the output of `main`).

**You can find the source code for these examples, and others, at [cyclejs/examples](https://github.com/cyclejs/cyclejs/tree/master/examples).**

`run()` ties `main()` and drivers together, as we saw in the last chapter. In the case of the DOM Driver, our `main()` will interact with the user through the DOM. Most of our examples will use the DOM Driver, but keep in mind that Cycle.js is modular and extensible. You could build an application, targeting Web Audio or native mobile for instance, without using the DOM Driver.

```javascript
function main(driverSources) {
  const driverSinks = {
    DOM: // transform driverSources.DOM
         // through a series of stream operators
  };
  return driverSinks;
}

const drivers = {
  DOM: makeDOMDriver('#app'),
};

run(main, drivers);
```

## Toggle a checkbox

Let's start with this `index.html` file, that should have an element dedicated to contain our application.

> Inside index.html

```html
<!-- html head goes here -->

<body>
  <div id="app"></div>
</body>
```

We will point our Cycle.js app to live inside `#app`. The `checkbox-app.js` file should look like this (before it is transpiled from ES6 to ES5, if that is required).

> checkbox-app.js

```javascript
import xs from 'xstream';
import {run} from '@cycle/xstream-run';
import {div, makeDOMDriver} from '@cycle/dom';

function main(sources) {
  const sinks = {DOM: null};
  return sinks;
}

run(main, {
  DOM: makeDOMDriver('#app'),
});
```

Cycle *DOM* is a package containing two drivers and some helpers to use those libraries. A DOM Driver is created with `makeDOMDriver()` and an HTML Driver (for server-side rendering) is created with `makeHTMLDriver()`. Cycle DOM also includes `div()`, `h1()`, `h2()`, `input()`, `ul()`, `li()`, `svg()`, etc. These functions output virtual elements (also known as [*Virtual Nodes*](https://github.com/paldepind/snabbdom/#virtual-node) or *VNodes*). See [`snabbdom`](https://github.com/paldepind/snabbdom) docs for details.

Our `main()`, for now, does nothing. It takes driver `sources` and outputs driver `sinks`. To make something appear on the screen, we need to output a stream of VNode in `sinks.DOM`. The name `DOM` in `sinks` must match the name we gave in the drivers object given to `run()`. This is how Cycle.js knows which drivers to match with which sink streams. This is also true for sources: we listen to DOM events by using `sources.DOM`.

We just added a stream of `false` mapped to a VNode. [`xs.of(x)`](https://github.com/staltz/xstream#of) creates a stream which just emits `x` once. Then we use [`map()`](https://github.com/staltz/xstream#map) to convert that to the virtual DOM VNode containing an `<input type="checkbox">` and a `<p>` element displaying `off` if the `toggled` boolean is `false`, and displaying `ON` otherwise.

```javascript
import xs from 'xstream';
import {run} from '@cycle/xstream-run';
import {div, input, p, makeDOMDriver} from '@cycle/dom';

function main(sources) {
  const sinks = {
    DOM: xs.of(false)
      .map(toggled =>
        div([
          input({attrs: {type: 'checkbox'}}), 'Toggle me',
          p(toggled ? 'ON' : 'off')
        ])
      )
  };
  return sinks;
}

run(main, {
  DOM: makeDOMDriver('#app'),
});
```

<a class="jsbin-embed" href="https://jsbin.com/robiyod/embed?output">JS Bin on jsbin.com</a>

This is nice: we can see the DOM elements generated by the virtual DOM elements created with `div()`, `input()`, and `p()`. But if we click the "Toggle me" checkbox, the label "off" under it does not change to "ON". That is because we are not listening to DOM events. In essence, our `main()` isn't listening to the *user*.

We do that by using `sources.DOM`, mapping `change` events on the checkbox to the `checked` value of the element (the first `map()`) to VNodes displaying that value. However, we need a [`.startWith()`](https://github.com/staltz/xstream#startWith) to give a default value to be converted to a VNode Stream. Without this, nothing would be shown! Why? Because our `sinks` is reacting to `sources`, but `sources` is reacting to `sinks`. If no one triggers the first event, nothing will happen. It is the same effect as meeting a stranger, and not having anything to say. Someone needs to take the initiative to start the conversation. That is what `main()` is doing: kickstarting the interaction, and then letting subsequent actions be mutual reactions between `main()` and the DOM Driver.

```diff
 import xs from 'xstream';
 import {run} from '@cycle/xstream-run';
 import {div, input, p, makeDOMDriver} from '@cycle/dom';

 function main(sources) {
   const sinks = {
-    DOM: xs.of(false)
+    DOM: sources.DOM.select('input').events('change')
+      .map(ev => ev.target.checked)
+      .startWith(false)
       .map(toggled =>
         div([
           input({attrs: {type: 'checkbox'}}), 'Toggle me',
           p(toggled ? 'ON' : 'off')
         ])
       )
   };
   return sinks;
 }

 run(main, {
   DOM: makeDOMDriver('#app')
 });
```

<a class="jsbin-embed" href="https://jsbin.com/makuye/embed?output">JS Bin on jsbin.com</a>

## HTTP requests

One of the most obvious requirements web apps normally have is to fetch and render data from the server. How would we build that with Cycle.js?

Suppose we have a backend with a database containing ten users. We want to have a front-end with one button "get a random user", and to display the user's details, like name and email. This is what we want to achieve:

<a class="jsbin-embed" href="https://jsbin.com/vedote/embed?output">JS Bin on jsbin.com</a>

Essentially we just need to make a request for the endpoint `/user/:number` whenever the button is clicked. Where would this HTTP request fit in a Cycle.js app?

*Sinks* are instructions from `main()` to drivers to perform side effects, and *sources* are readable side effects. HTTP requests are sinks, and HTTP responses are sources.

The [HTTP Driver](https://github.com/cyclejs/cyclejs/tree/master/http) is similar in style to the DOM Driver: it expects a sink stream (for requests), and gives you a source stream (for responses). Instead of studying the details of how the HTTP Driver works, let's see what a basic HTTP example looks like.

If HTTP requests are sent when the button is clicked, then the HTTP request stream should depend directly on the button click stream. `getRandomUser$` is the request stream we give to the HTTP Driver, by returning it as a sink in the `main()` function.

```javascript
function main(sources) {
  // ...
  const click$ = sources.DOM.select('.get-random').events('click');

  const getRandomUser$ = click$.map(() => {
    const randomNum = Math.round(Math.random() * 9) + 1;
    return {
      url: 'http://jsonplaceholder.typicode.com/users/' + String(randomNum),
      category: 'users',
      method: 'GET'
    };
  });

  // ...

  return {
    // ...
    HTTP: getRandomUser$,
  };
}
```

We still need to display data for the current user, and this comes only when we get an HTTP response. For that purpose, we need the stream of user data to depend directly on the HTTP response stream. This is available from `main`'s input: `sources.HTTP` (the name `HTTP` needs to match the driver name you gave for the HTTP driver when calling `run()`).

```javascript
function main(sources) {
  // ...

  const user$ = sources.HTTP.select('users')
    .flatten()
    .map(res => res.body);

  // ...
}
```

`sources.HTTP` is an "HTTP Source", representing all the network responses for this app. `select(category)` is an API specific to the HTTP Source that returns a stream of all response streams that are related to the `category` given. Because that output is a stream-of-streams, we apply `flatten()`, to get a flattened stream of responses. Check above for the declaration of `getRandomUser$` where we returned a request object with a `category: users` field. This might feel like magic right now, so read the [HTTP Driver docs](https://github.com/cyclejs/cyclejs/tree/master/http) if you're curious about the details. We map each response `res` to `res.body` in order to get the JSON data from the response and ignore other fields like HTTP status.

We still haven't specified how to render our app. We should display to the DOM whatever data we have from the current user in `user$`. So the VNode stream called `vdom$` should depend directly on `user$`.

```javascript
function main(sources) {
  // ...
  const vdom$ = user$.map(user =>
    div('.users', [
      button('.get-random', 'Get random user'),
      div('.user-details', [
        h1('.user-name', user.name),
        h4('.user-email', user.email),
        a('.user-website', {href: user.website}, user.website)
      ])
    ])
  );
  // ...
}
```

However, initially, there won't be any `user$` event, because those only happen when the user clicks. This is the same "conversation initiative" problem we saw in the previous "checkbox" example. So we need to make `user$` start with a `null` user, and in case `vdom$` sees a null user, it renders just the button. Otherwise, if we have real user data, we also display their name, their email, and website.

```diff
 function main(sources) {
   // ...

   const user$ = sources.HTTP.select('users')
     .flatten()
     .map(res => res.body)
+    .startWith(null);

   const vdom$ = user$.map(user =>
     div('.users', [
       button('.get-random', 'Get random user'),
-      div('.user-details', [
+      user === null ? null : div('.user-details', [
         h1('.user-name', user.name),
         h4('.user-email', user.email),
         a('.user-website', {href: user.website}, user.website)
       ])
     ])
   );

   // ...
 }
```

We give `vdom$` to the DOM Driver, and it renders those for us.
When done, the whole code looks like this.

```javascript
import xs from 'xstream';
import {run} from '@cycle/xstream-run';
import {div, button, h1, h4, a, makeDOMDriver} from '@cycle/dom';
import {makeHTTPDriver} from '@cycle/http';

function main(sources) {
  const getRandomUser$ = sources.DOM.select('.get-random').events('click')
    .map(() => {
      const randomNum = Math.round(Math.random() * 9) + 1;
      return {
        url: 'http://jsonplaceholder.typicode.com/users/' + String(randomNum),
        category: 'users',
        method: 'GET'
      };
    });

  const user$ = sources.HTTP.select('users')
    .flatten()
    .map(res => res.body)
    .startWith(null);

  const vdom$ = user$.map(user =>
    div('.users', [
      button('.get-random', 'Get random user'),
      user === null ? null : div('.user-details', [
        h1('.user-name', user.name),
        h4('.user-email', user.email),
        a('.user-website', {attrs: {href: user.website}}, user.website)
      ])
    ])
  );

  return {
    DOM: vdom$,
    HTTP: getRandomUser$
  };
}

run(main, {
  DOM: makeDOMDriver('#app'),
  HTTP: makeHTTPDriver()
});
```

<a class="jsbin-embed" href="https://jsbin.com/vedote/embed?output">JS Bin on jsbin.com</a>

## Increment a counter

We saw how to use the *sources and sinks* pattern of building user interfaces, but our examples didn't have state: the label just reacted to the checkbox event, and the user details view just showed what came from the HTTP response. Normally applications have state in memory, so let's see how to build a Cycle.js app for that case.

If we have a counter stream (emitting events to tell the current counter value), displaying the counter is as simple as this.

```javascript
count$.map(count =>
  div([
    button('.increment', 'Increment'),
    button('.decrement', 'Decrement'),
    p('Counter: ' + count)
  ])
)
```

> ### What is the `$` convention?
>
> Notice we used the name `count$` for the stream of current counter values. The dollar sign `$` *suffixed* to a name is a soft convention to indicate that the variable is a stream. It is a naming helper to indicate types.
>
> Suppose you have a stream of VNode depending on a stream of "name" strings
>
> `const vdom$ = name$.map(name => h1(name));`
>
> Notice that the function inside `map` takes `name` as an argument, while the stream is named `name$`. The naming convention indicates that `name` is the value being emitted by `name$`. In general, `foobar$` emits `foobar`. Without this convention, if `name$` would be named simply `name`, it would confuse readers about the types involved. Also, `name$` is succinct compared to alternatives like `nameStream`, `nameObservable`, or `nameObs`. This convention can also be extended to arrays: use plurality to indicate the type is an array. Example: `vdoms` is an array of `vdom` but `vdom$` is a stream of `vdom`.

But how do we create a `count$`? Clearly it must depend on increment clicks and decrement clicks. The former should mean a "+1" operation, and the latter a "-1" operation.

```javascript
const action$ = xs.merge(
  DOM.select('.decrement').events('click').mapTo(-1),
  DOM.select('.increment').events('click').mapTo(+1)
);
```

The [`merge`](https://github.com/staltz/xstream#merge) operator allows us to get an event stream of actions, either increment or decrement actions. In this sense, `merge` has *OR* semantics. But this still isn't a `count$`. It is just an `action$`.

`count$` should begin with zero and should later be the sum of all the numbers emitted by `action$`. To join all events on a stream over time, we use the operator [`fold()`](https://github.com/staltz/xstream#fold):

```js
const count$ = action$.fold((x, y) => x + y, 0);
```

What does `fold` do? It is similar to [`reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce), allowing us to accumulate values over the sequence. Also, `fold` has some `startWith` behavior included, because it takes a `seed` argument (we gave the number `0`) and emits that initially.

![fold counter](img/fold-counter.svg)

If we put `action$` and `count$` together in our `main()`, we can implement the counter like this:

<a class="jsbin-embed" href="https://jsbin.com/husiyul/embed?output">JS Bin on jsbin.com</a>

```javascript
import xs from 'xstream';
import {run} from '@cycle/xstream-run';
import {div, button, p, makeDOMDriver} from '@cycle/dom';

function main(sources) {
  const action$ = xs.merge(
    sources.DOM.select('.dec').events('click').mapTo(-1),
    sources.DOM.select('.inc').events('click').mapTo(+1)
  );

  const count$ = action$.fold((x, y) => x + y, 0);

  const vdom$ = count$.map(count =>
    div([
      button('.dec', 'Decrement'),
      button('.inc', 'Increment'),
      p('Counter: ' + count)
    ])
  );

  return {
    DOM: vdom$
  };
}

run(main, {
  DOM: makeDOMDriver('#app')
});
```

## Body mass index calculator

Now that we've got the hang of Cycle.js apps with state, let's tackle something a bit larger. Consider the following [BMI](https://en.wikipedia.org/wiki/Body_mass_index) calculator: it has a slider to select the weight, a slider to select the height, and the text indicates the calculated BMI from the weight and height values selected.

<a class="jsbin-embed" href="https://jsbin.com/nucepu/embed?output">JS Bin on jsbin.com</a>

In the previous example, we had the actions *decrement* and *increment*. In this example, we have "change weight" and "change height". These seem straightforward to implement.

```javascript
const changeWeight$ = sources.DOM.select('.weight')
  .events('input')
  .map(ev => ev.target.value);

const changeHeight$ = sources.DOM.select('.height')
  .events('input')
  .map(ev => ev.target.value);
```

By now we know that app state is usually initialized with `startWith` or `fold`. We need the *height* and *weight* as *values over time*, not as *change events*. In order to represent *height* as state, we just need to give an initial value prepended to `changeHeight$`.

```javascript
const weight$ = changeWeight$.startWith(70);
const height$ = changeHeight$.startWith(170);
```

To combine these two pieces of state and use their values to compute the BMI, we use the xstream [`combine`](https://github.com/staltz/xstream#combine) operator. We saw in the previous example that `merge` had *OR* semantics. `combine` has, on the other hand, *AND* semantics. For instance, to compute the BMI, we need a `weight` value *AND* a `height` value. `combine` takes **multiple** streams as input, and produces **one** stream of arrays that contain **multiple** values, one for each input stream.

```javascript
const bmi$ = xs.combine(weight$, height$)
  .map(([weight, height]) => {
    const heightMeters = height * 0.01;
    return Math.round(weight / (heightMeters * heightMeters));
  });
  ```

Now we just need a function to visualize the BMI result and the sliders. We do that by mapping `bmi$` to a stream of VNode, and giving that to the `DOM` driver.

<a class="jsbin-embed" href="https://jsbin.com/wojokof/embed?output">JS Bin on jsbin.com</a>

```javascript
import xs from 'xstream';
import {run} from '@cycle/xstream-run';
import {div, input, h2, makeDOMDriver} from '@cycle/dom';

function main(sources) {
  const changeWeight$ = sources.DOM.select('.weight')
    .events('input')
    .map(ev => ev.target.value);

  const changeHeight$ = sources.DOM.select('.height')
    .events('input')
    .map(ev => ev.target.value);

  const weight$ = changeWeight$.startWith(70);
  const height$ = changeHeight$.startWith(170);

  const bmi$ = xs.combine(weight$, height$)
    .map(([weight, height]) => {
      const heightMeters = height * 0.01;
      return Math.round(weight / (heightMeters * heightMeters));
    });

  const vdom$ = bmi$.map(bmi =>
    div([
      div([
        'Weight ___kg',
        input('.weight', {attrs: {type: 'range', min: 40, max: 140}})
      ]),
      div([
        'Height ___cm',
        input('.height', {attrs: {type: 'range', min: 140, max: 210}})
      ]),
      h2('BMI is ' + bmi)
    ])
  );

  return {
    DOM: vdom$
  };
}

run(main, {
  DOM: makeDOMDriver('#app')
});
```

This code works. We can get the calculated BMI when we move the slider. However, maybe you noticed, the labels for weight and height do not show what the slider is selecting. Instead, they just show e.g. `Weight ___kg`, which is useless since we do not know what value we are choosing for the weight.

The problem happens because when we map on `bmi$`, we do not have the `weight` and `height` values anymore. Therefore, for the function which renders the VNode, we need to use a stream which emits a complete amount of data instead of just BMI data. We need a `state$`.

```javascript
const state$ = xs.combine(weight$, height$)
  .map(([weight, height]) => {
    const heightMeters = height * 0.01;
    const bmi = Math.round(weight / (heightMeters * heightMeters));
    return {weight, height, bmi};
  });
  ```

Below is the program that uses `state$` to render all dynamic values correctly to the DOM.

<a class="jsbin-embed" href="https://jsbin.com/nucepu/embed?output">JS Bin on jsbin.com</a>

```javascript
import xs from 'xstream';
import {run} from '@cycle/xstream-run';
import {div, input, h2, makeDOMDriver} from '@cycle/dom';

function main(sources) {
  const changeWeight$ = sources.DOM.select('.weight')
    .events('input')
    .map(ev => ev.target.value);

  const changeHeight$ = sources.DOM.select('.height')
    .events('input')
    .map(ev => ev.target.value);

  const weight$ = changeWeight$.startWith(70);
  const height$ = changeHeight$.startWith(170);

  const state$ = xs.combine(weight$, height$)
    .map(([weight, height]) => {
      const heightMeters = height * 0.01;
      const bmi = Math.round(weight / (heightMeters * heightMeters));
      return {weight, height, bmi};
    });

  const vdom$ = state$.map(({weight, height, bmi}) =>
    div([
      div([
        'Weight ' + weight + 'kg',
        input('.weight', {type: 'range', min: 40, max: 140, value: weight})
      ]),
      div([
        'Height ' + height + 'cm',
        input('.height', {type: 'range', min: 140, max: 210, value: height})
      ]),
      h2('BMI is ' + bmi)
    ])
  );

  return {
    DOM: vdom$
  };
}

run(main, {
  DOM: makeDOMDriver('#app')
});
```

Great, this program functions exactly like we want it to. Weight and height labels react to the sliders being dragged, and the BMI result gets recalculated as well.

However, we wrote all the code inside one function: `main()`. This approach doesn't scale, and even for a small app like this, it already looks too large and is doing too many things.

We need a proper architecture for user interfaces that follows the reactive, functional, and cyclic principles of Cycle.js.

# Model-View-Intent

## Split main into parts

We can write our entire Cycle.js program inside the `main()` function, like we did in the [previous chapter](/basic-examples.html#body-mass-index-calculator). However, any programmer knows this isn't a good idea. Once `main()` grows too large, it becomes hard to maintain.

**MVI is a simple pattern to refactor the main() function into three parts: Intent (to listen to the user), Model (to process information), and View (to output back to the user).**

![main equal MVI](img/main-eq-mvi.svg)

Let's see how we can refactor the `main()` function we wrote for calculating BMI:

```javascript
import xs from 'xstream';
import {run} from '@cycle/xstream-run';
import {div, input, h2, makeDOMDriver} from '@cycle/dom';

function main(sources) {
  const changeWeight$ = sources.DOM.select('.weight')
    .events('input')
    .map(ev => ev.target.value);

  const changeHeight$ = sources.DOM.select('.height')
    .events('input')
    .map(ev => ev.target.value);

  const weight$ = changeWeight$.startWith(70);
  const height$ = changeHeight$.startWith(170);

  const state$ = xs.combine(weight$, height$)
    .map(([weight, height]) => {
      const heightMeters = height * 0.01;
      const bmi = Math.round(weight / (heightMeters * heightMeters));
      return {weight, height, bmi};
    });

  const vdom$ = state$.map(({weight, height, bmi}) =>
    div([
      div([
        'Weight ' + weight + 'kg',
        input('.weight', {type: 'range', min: 40, max: 140, value: weight})
      ]),
      div([
        'Height ' + height + 'cm',
        input('.height', {type: 'range', min: 140, max: 210, value: height})
      ]),
      h2('BMI is ' + bmi)
    ])
  );

  return {
    DOM: vdom$
  };
}

run(main, {
  DOM: makeDOMDriver('#app')
});
```

We have plenty of anonymous functions which could be refactored away from `main`, such as the BMI calculation, VNode rendering, etc.

```diff
 import xs from 'xstream';
 import {run} from '@cycle/xstream-run';
 import {div, input, h2, makeDOMDriver} from '@cycle/dom';

+function renderWeightSlider(weight) {
+  return div([
+    'Weight ' + weight + 'kg',
+    input('.weight', {type: 'range', min: 40, max: 140, value: weight})
+  ]);
+}

+function renderHeightSlider(height) {
+  return div([
+    'Height ' + height + 'cm',
+    input('.height', {type: 'range', min: 140, max: 210, value: height})
+  ]);
+}

+function bmi(weight, height) {
+  const heightMeters = height * 0.01;
+  return Math.round(weight / (heightMeters * heightMeters));
+}

 function main(sources) {
   const changeWeight$ = sources.DOM.select('.weight')
     .events('input')
     .map(ev => ev.target.value);

   const changeHeight$ = sources.DOM.select('.height')
     .events('input')
     .map(ev => ev.target.value);

   const weight$ = changeWeight$.startWith(70);
   const height$ = changeHeight$.startWith(170);

   const state$ = xs.combine(weight$, height$)
     .map(([weight, height]) => {
-      const heightMeters = height * 0.01;
-      const bmi = Math.round(weight / (heightMeters * heightMeters));
-      return {weight, height, bmi};
+      return {weight, height, bmi: bmi(weight, height)};
     });

   const vdom$ = state$.map(({weight, height, bmi}) =>
     div([
-      div([
-        'Weight ' + weight + 'kg',
-        input('.weight', {type: 'range', min: 40, max: 140, value: weight})
-      ]),
-      div([
-        'Height ' + height + 'cm',
-        input('.height', {type: 'range', min: 140, max: 210, value: height})
-      ]),
+      renderWeightSlider(weight),
+      renderHeightSlider(height),
       h2('BMI is ' + bmi)
     ])
   );

   return {
     DOM: vdom$
   };
 }

 run(main, {
   DOM: makeDOMDriver('#app')
 });
```

`main` still has to handle too many concerns. Can we do better? Yes, we can, by using the insight that `state$.map(state => someVNode)` is a *View* function: renders visual elements as a transformation of state. Let's introduce `function view(state$)`.

```diff
 import xs from 'xstream';
 import {run} from '@cycle/xstream-run';
 import {div, input, h2, makeDOMDriver} from '@cycle/dom';

 function renderWeightSlider(weight) {
   return div([
     'Weight ' + weight + 'kg',
     input('.weight', {type: 'range', min: 40, max: 140, value: weight})
   ]);
 }

 function renderHeightSlider(height) {
   return div([
     'Height ' + height + 'cm',
     input('.height', {type: 'range', min: 140, max: 210, value: height})
   ]);
 }

 function bmi(weight, height) {
   const heightMeters = height * 0.01;
   return Math.round(weight / (heightMeters * heightMeters));
 }

+function view(state$) {
+  return state$.map(({weight, height, bmi}) =>
+    div([
+      renderWeightSlider(weight),
+      renderHeightSlider(height),
+      h2('BMI is ' + bmi)
+    ])
+  );
+}

 function main(sources) {
   const changeWeight$ = sources.DOM.select('.weight')
     .events('input')
     .map(ev => ev.target.value);

   const changeHeight$ = sources.DOM.select('.height')
     .events('input')
     .map(ev => ev.target.value);

   const weight$ = changeWeight$.startWith(70);
   const height$ = changeHeight$.startWith(170);

   const state$ = xs.combine(weight$, height$)
     .map(([weight, height]) => {
       return {weight, height, bmi: bmi(weight, height)};
     });

-  const vdom$ = state$.map(({weight, height, bmi}) =>
-    div([
-      renderWeightSlider(weight),
-      renderHeightSlider(height),
-      h2('BMI is ' + bmi)
-    ])
-  );
+  const vdom$ = view(state$);

   return {
     DOM: vdom$
   };
 }

 run(main, {
   DOM: makeDOMDriver('#app')
 });
```

Now, `main` is much smaller. But is it doing *one thing*? We still have `changeWeight$`, `changeHeight$`, `weight$`, `height$`, `state$`, and the return using `view(state$)`. Normally when we work with a *View*, we also have a *Model*. What Models normally do is **manage state**. In our case, however, we have `state$` which is self-responsible for its own changes, because it is [reactive](/observables.html#reactive-programming). But anyway we have code that defines how `state$` depends on `changeWeight$` and `changeHeight$`. We can put that code inside a `model()` function.

```diff
 import xs from 'xstream';
 import {run} from '@cycle/xstream-run';
 import {div, input, h2, makeDOMDriver} from '@cycle/dom';

 // ...

+function model(changeWeight$, changeHeight$) {
+  const weight$ = changeWeight$.startWith(70);
+  const height$ = changeHeight$.startWith(170);
+
+  return xs.combine(weight$, height$)
+    .map(([weight, height]) => {
+      return {weight, height, bmi: bmi(weight, height)};
+    });
+}

 function view(state$) {
   return state$.map(({weight, height, bmi}) =>
     div([
       renderWeightSlider(weight),
       renderHeightSlider(height),
       h2('BMI is ' + bmi)
     ])
   );
 }

 function main(sources) {
   const changeWeight$ = sources.DOM.select('.weight')
     .events('input')
     .map(ev => ev.target.value);

   const changeHeight$ = sources.DOM.select('.height')
     .events('input')
     .map(ev => ev.target.value);

-  const weight$ = changeWeight$.startWith(70);
-  const height$ = changeHeight$.startWith(170);
-
-  const state$ = xs.combine(weight$, height$)
-    .map(([weight, height]) => {
-      return {weight, height, bmi: bmi(weight, height)};
-    });
+  const state$ = model(changeWeight$, changeHeight$);

   const vdom$ = view(state$);

   return {
     DOM: view(state$)
   };
 }

 run(main, {
   DOM: makeDOMDriver('#app')
 });
```

`main` still defines `changeWeight$` and `changeHeight$`. What are these streams? They are event streams of *Actions*. In the [previous chapter about basic examples](/basic-examples.html#increment-and-decrement-a-counter) we had an `action$` stream for incrementing and decrementing a counter. These Actions are deduced or interpreted from DOM events. Their names indicate the user's *intentions*. We can group these stream definitions in an `intent()` function:

```diff
 import xs from 'xstream';
 import {run} from '@cycle/xstream-run';
 import {div, input, h2, makeDOMDriver} from '@cycle/dom';

 // ...

+function intent(domSource) {
+  return {
+    changeWeight$: domSource.select('.weight').events('input')
+      .map(ev => ev.target.value),
+    changeHeight$: domSource.select('.height').events('input')
+      .map(ev => ev.target.value)
+  };
+}

-function model(changeWeight$, changeHeight$) {
-  const weight$ = changeWeight$.startWith(70);
-  const height$ = changeHeight$.startWith(170);
+function model(actions) {
+  const weight$ = actions.changeWeight$.startWith(70);
+  const height$ = actions.changeHeight$.startWith(170);

   return xs.combine(weight$, height$)
     .map(([weight, height]) => {
       return {weight, height, bmi: bmi(weight, height)};
     });
 }

 function view(state$) {
   return state$.map(({weight, height, bmi}) =>
     div([
       renderWeightSlider(weight),
       renderHeightSlider(height),
       h2('BMI is ' + bmi)
     ])
   );
 }

 function main(sources) {
-  const changeWeight$ = sources.DOM.select('.weight')
-    .events('input')
-    .map(ev => ev.target.value);
-
-  const changeHeight$ = sources.DOM.select('.height')
-    .events('input')
-    .map(ev => ev.target.value);
+  const actions = intent(sources.DOM);

-  const state$ = model(changeWeight$, changeHeight$);
+  const state$ = model(actions);

   const vdom$ = view(state$);

   return {
     DOM: vdom$
   };
 }

 run(main, {
   DOM: makeDOMDriver('#app')
 });
```

`main` is finally small enough, and works on one level of abstraction, defining how actions are created from DOM events, flowing to model and then to view, and finally back to the DOM. Because these steps are a chain, we can refactor `main` to compose those three functions `intent`, `model`, and `view` together:

```javascript
function main(sources) {
  return {DOM: view(model(intent(sources.DOM)))};
}
```

Seems like we cannot achieve a simpler format for `main`.

## Summarized

- `intent()` function
  - Purpose: interpret DOM events as user's intended actions
  - Input: DOM source
  - Output: Action Streams
- `model()` function
  - Purpose: manage state
  - Input: Action Streams
  - Output: State Stream
- `view()` function
  - Purpose: visually represent state from the Model
  - Input: State Stream
  - Output: Stream of Virtual DOM nodes as the DOM Driver sink

**Is Model-View-Intent an architecture?** Is this a new architecture? If so, how is it different to Model-View-Controller?

## What MVC is really about

[Model-View-Controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) (MVC) has existed since the 80s as the cornerstone architecture for user interfaces. It has inspired multiple other important architectures such as [MVVM](https://en.wikipedia.org/wiki/Model_View_ViewModel) and [MVP](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter).

MVC is characterized by the Controller: a component which manipulates the other parts, updating them accordingly whenever the user does an action.

![MVC](img/mvc-diagram.svg)

The Controller in MVC is incompatible with our reactive ideals, because it is a proactive component (implying either passive Model or passive View). However, the original idea in MVC was a method for translating information between two worlds: that of the computer's digital realm and the user's mental model. In Trygve's own words:

> *The essential purpose of MVC is to bridge the gap between the human user's mental model and the digital model that exists in the computer.* <br />&#8211; [Trygve Reenskaug](http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html), inventor of MVC

We can keep the MVC idea while avoiding a proactive Controller. In fact, if you observe our `view()` function, it does nothing else than transform state (digital model in the computer) to a visual representation useful for the user. View is a translation from one language to another: from binary data to English and other human-friendly languages.

![view translation](img/view-translation.svg)

The opposite direction should be also a straightforward translation from the user's actions to *new* digital data. This is precisely what `intent()` does: interprets what the user is trying to affect in the context of the digital model.

![intent translation](img/intent-translation.svg)

Model-View-Intent (MVI) is **reactive**, **functional**, and follows the **core idea in MVC**. It is reactive because Intent observes the User, Model observes the Intent, View observes the Model, and the User observes the View. It is functional because each of these components is expressed as a [referentially transparent](https://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29) function over streams. It follows the original MVC purpose because View and Intent bridge the gap between the user and the digital model, each in one direction.

> ### Why CSS selectors?
>
> Some programmers get concerned about `DOM.select(selector).events(eventType)` being a bad practice because it resembles spaghetti code in jQuery-based programs. They would rather prefer the virtual DOM elements to specify handler callbacks for events, such as `onClick={this.handleClick()}`.
>
> The choice for selector-based event querying in Cycle *DOM* is an informed and rational decision. This strategy enables MVI to be reactive and is inspired by the [open-closed principle](https://en.wikipedia.org/wiki/Open/closed_principle).
>
> **Important for reactivity and MVI.** If we had Views with `onClick={this.handleClick()}`, it would mean Views would *not* be anymore a simple translation from digital model to user mental model, because we also specify what happens as a consequence of the user's actions. To keep all parts in a Cycle.js app reactive, we need the View to simply declare a visual representation of the Model. Otherwise the View becomes a Proactive component. It is beneficial to keep the View responsible only for declaring how state is visually represented: it has a [single responsibility](https://en.wikipedia.org/wiki/Single_responsibility_principle) and is friendly to UI designers. It is also conceptually aligned with the [original View in MVC](http://heim.ifi.uio.no/~trygver/1979/mvc-2/1979-12-MVC.pdf): "*... a view should never know about user input, such as mouse operations and
keystrokes.*"
>
> **Adding user actions shouldn't affect the View.** If you need to change Intent code to grab new kinds of events from the element, you don't need to modify code in the VTree element. The View stays untouched, and it should, because translation from state to DOM hasn't changed.
>
> The MVI strategy in Cycle DOM is to name most elements in your View with appropriate semantic classnames. Then you do not need to worry which of those can have event handlers, if all of them can. The classname is the common artifact which the View (DOM sink) and the Intent (DOM source) can use to refer to the same element.
>
> As we will see in the [Components](/components.html) chapter, risk of global className collision is not a problem in Cycle.js because of the `isolate()` helper.

MVI is an architecture, but in Cycle it is nothing else than simply a function decomposition of `main()`.

![main equal MVI](img/main-eq-mvi.svg)

In fact, MVI itself just naturally emerged from our refactoring of `main()` split into functions. This means Model, View, and Intent are not rigorous containers where you should place code. Instead, they are just a convenient way of organizing code, and are very cheap to create because they are simply functions. Whenever convenient, you should split a function if it becomes too large. Use MVI as a guide on how to organize code, but don't confine your code within its limits if it doesn't make sense.

This is what it means to say Cycle.js is *sliceable*. MVI is just one way of slicing `main()`.

> ### "Sliceable"?
>
> With "sliceable", we mean the ability to refactor the program by extracting pieces of code without having to significantly modify their surroundings. Sliceability is a feature often found in functional programming languages, especially in LISP-based languages like [Clojure](https://en.wikipedia.org/wiki/Clojure), which use S-expressions to enable treating [*code as data*](https://en.wikipedia.org/wiki/Homoiconicity).

## Pursuing DRY

As good programmers writing good codebases, we must follow [DRY: Don't Repeat Yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself). The MVI code we wrote is not entirely DRY.

For instance, the View rendering of the sliders share a significant amount of code. And in the Intent, we have some duplication of the `DOM.select().events()` streams.

```javascript
function renderWeightSlider(weight) {
  return div([
    'Weight ' + weight + 'kg',
    input('.weight', {type: 'range', min: 40, max: 140, value: weight})
  ]);
}

function renderHeightSlider(height) {
  return div([
    'Height ' + height + 'cm',
    input('.height', {type: 'range', min: 140, max: 210, value: height})
  ]);
}

function intent(domSource) {
  return {
    changeWeight$: domSource.select('.weight')
      .events('input')
      .map(ev => ev.target.value),
    changeHeight$: domSource.select('.height')
      .events('input')
      .map(ev => ev.target.value)
  };
}
```

We could create functions to remove this duplication, as such:

```javascript
function renderSlider(label, value, unit, className, min, max) {
  return div([
    '' + label + ' ' + value + unit,
    input('.' + className, {type: 'range', min, max, value})
  ]);
}

function renderWeightSlider(weight) {
  return renderSlider('Weight', weight, 'kg', 'weight', 40, 140);
}

function renderHeightSlider(height) {
  return renderSlider('Height', height, 'cm', 'height', 140, 210);
}

function getSliderEvent(domSource, className) {
  return domSource.select('.' + className)
    .events('input')
    .map(ev => ev.target.value);
}

function intent(domSource) {
  return {
    changeWeight$: getSliderEvent(domSource, 'weight'),
    changeHeight$: getSliderEvent(domSource, 'height')
  };
}
```

But this still isn't ideal: we seem to have *more* code now. What we really want is just to create *labeled sliders*: one for height, and the other for weight. We should be able to build a generic and reusable labeled slider.

# Components

## Automatically reusable

User interfaces are usually made up of many reusable pieces: buttons, charts, sliders, hoverable avatars, smart form fields, etc. In many frameworks, including Cycle.js, these are called components. However, in this framework they have a special property.

**Any Cycle.js app can be reused as a component in a larger Cycle.js app.**

How is that so? In any framework you can build a program that just makes one slider. By now, we know how to make a Cycle.js `main()` that makes a smart slider widget. Then, since `main()` is just a function taking inputs from the external world and generating outputs in return, we can just call that function inside a larger Cycle.js app.

Each of these "small Cycle.js `main()` functions" are called **dataflow components**. The sources which a dataflow component receives are streams provided by its parent, and sinks are streams given back to the parent. All along, we have been building dataflow components, because the `main()` given to `run(main, drivers)` is also a dataflow component. Its parent are the drivers, because that is where its sources come from and where its sinks go to.

![dataflow component](img/dataflow-component.svg)

To learn by doing, let's just make a dataflow component for a single labeled slider. It should take user events as input, and generate a virtual DOM stream of a slider element. Besides the virtual DOM, it might also output a value: the stream of slider values. It might also take attributes (from its parent) as input to customize some behavior or looks. These are sometimes called *props* ("properties") in other frameworks.

## A labeled slider component

A labeled slider has two parts: a label and slider, side by side, where the label always displays the current dynamic value of the slider.

<a class="jsbin-embed" href="//jsbin.com/napoke/embed?output">JS Bin on jsbin.com</a>

Every labeled slider has some properties:

 - Label text (`'Weight'`, `'Height'`, etc)
 - Unit text (`'kg'`, `'cm'`, etc)
 - Min value
 - Max value
 - Initial value

These props can be encoded as an object, wrapped in a stream, and passed to our `main()` function as a *source* input:

```javascript
function main(sources) {
  const props$ = sources.props;
  // ...
  return sinks;
}
```

To use this main function, we call `run`:

```javascript
run(main, {
  props: () => xs.of({
    label: 'Weight', unit: 'kg', min: 40, value: 70, max: 140
  }),
  DOM: makeDOMDriver('#app')
});
```

Remember that even though we are building a component, we are assuming our labeled slider to be our main program. Then, because `props` are an input given to the labeled slider from its parent, the only parent of `main()` in this case is `run`. That is why we need to configure `props` as a fake driver.

The other input to this labeled slider program is the DOM source representing user events:

```diff
 function main(sources) {
+  const domSource = sources.DOM;
   const props$ = sources.props;
   // ...
   return sinks;
 }
```

The remainder of the program is rather easy given that we've written the same labeled slider in the two previous chapters. However, this time we take props as the initial value.

```javascript
function main(sources) {
  const domSource = sources.DOM;
  const props$ = sources.props;

  const newValue$ = domSource
    .select('.slider')
    .events('input')
    .map(ev => ev.target.value);

  const state$ = props$
    .map(props => newValue$
      .map(val => ({
        label: props.label,
        unit: props.unit,
        min: props.min,
        value: val,
        max: props.max
      }))
      .startWith(props)
    )
    .flatten()
    .remember();

  const vdom$ = state$
    .map(state =>
      div('.labeled-slider', [
        span('.label',
          state.label + ' ' + state.value + state.unit
        ),
        input('.slider', {
          attrs: {type: 'range', min: state.min, max: state.max, value: state.value}
        })
      ])
    );

  const sinks = {
    DOM: vdom$,
    value: state$.map(state => state.value),
  };
  return sinks;
}
```

You might have noticed that besides the virtual DOM output, we also return the `value$` stream as a sink:

```diff
   // ...
   const sinks = {
     DOM: vdom$,
+    value: value$,
   };
   return sinks;
 }
```

This value stream is important as a sink if the parent wishes to use the numeric value for some calculations, such as that of BMI. In the program we wrote above, the parent of `main()` are the drivers. The drivers don't need to use `value$`, that's why we don't need a driver named `value`. However, when the parent of the slider component is another dataflow component, like in the next section, then `value$` will be important.

> How to name sources/sinks?
>
> You may have noticed that we chose the name `value` as a sink, not `value$`. Does this contradict our convention that streams should always be suffixed with `$`? Not particularly.
>
> Sources and sinks are an exception because they are special sockets that connect the internals of your component with the external world. Their names are just "keys" used to put or get streams. In the case of `main`, those keys need to match the same keys you gave to the `drivers` object in `run(main, drivers)`. Notice how each driver indexed by a key in the `drivers` object *is not* a stream. They are functions, because drivers are functions.
>
> This is why we shouldn't give the name `DOM$`, because in the `drivers` object, the value behind that key is a function (the DOM Driver), and in the `main` function, `sources.DOM` is the DOM Source object with methods like `select()` and `events()`.
>
> Try to maintain the convention that source and sink names are just *keys* in the sources object and sinks object. You may then "pick" your stream from the sources, like we did with `const props$ = sources.props;` for instance.

## Using a component

Now that our dataflow component for a labeled slider is ready, we can use it in the context of a larger application. First, we will rename our component to `LabeledSlider`, and `main()` will refer to our larger application.

```diff
-function main(sources) {
+function LabeledSlider(sources) {
   const domSource = sources.DOM;
   const props$ = sources.props;

   // ...

   return sinks;
 }

+function main(sources) {
+  // Call LabeledSlider() here...
+}
```

Since `LabeledSlider` is just a function, we can call it with some sources to get its sinks as output.

```javascript
function main(sources) {
  const props$ = xs.of({
    label: 'Radius', unit: '', min: 10, value: 30, max: 100
  });
  const childSources = {DOM: sources.DOM, props: props$};
  const labeledSlider = LabeledSlider(childSources);
  const childVDom$ = labeledSlider.DOM;
  const childValue$ = labeledSlider.value;

  // ...
}
```

> Why name components with CapitalCase?
>
> You probably noticed we named the dataflow component as `LabeledSlider`. Usually in JavaScript, capitalized names are used for classes and constructor functions. Since Cycle.js uses functional programming techniques heavily, Object-oriented programming conventions are irrelevant, there are rarely (or never) classes in Cycle.js apps.
>
> For this reason, capitalized names become available in the functional programming flavor of JavaScript. We will follow the convention of capitalized names such as `FooButton` for dataflow components (in other words, small Cycle.js apps). Their camel-case counterpart such as `fooButton` will refer to the output of `FooButton` function when called, i.e., the sinks object.

Now we have `childVDom$` and `childValue$` as sinks from the labeled slider, available for use as regular streams in the context of the `main()` parent. We use `childValue$` to render a circle with radius equal to the slider's value, and use `childVDom$` to embed the slider's virtual DOM in the parent's virtual DOM:

```javascript
function main(sources) {
  // ...

  const childVDom$ = labeledSlider.DOM;
  const childValue$ = labeledSlider.value;

  const vdom$ = xs.combine(childValue$, childVDom$)
    .map(([value, childVDom]) =>
      div([
        childVDom,
        div({style: {
          backgroundColor: '#58D3D8',
          width: String(2 * value) + 'px',
          height: String(2 * value) + 'px',
          borderRadius: String(value) + 'px'
        }})
      ])
    );

  return {
    DOM: vdom$
  };
}
```

As a result, we get a Cycle.js program where the labeled slider controls the size of a rendered circle.

<a class="jsbin-embed" href="//jsbin.com/yojoho/embed?output">JS Bin on jsbin.com</a>

## Isolating multiple instances

Our labeled sliders were originally built for the BMI example, so we should see how the component we just built can be used in the BMI example.

The naïve approach is to simply call `LabeledSlider()` twice, once with props for weight, and again with props for height:

<a class="jsbin-embed" href="//jsbin.com/lagegax/embed?output">JS Bin on jsbin.com</a>

```javascript
function main(sources) {
  const weightProps$ = xs.of({
    label: 'Weight', unit: 'kg', min: 40, value: 70, max: 150
  });
  const heightProps$ = xs.of({
    label: 'Height', unit: 'cm', min: 140, value: 170, max: 210
  });

  const weightSources = {DOM: sources.DOM, props: weightProps$};
  const heightSources = {DOM: sources.DOM, props: heightProps$};

  const weightSlider = LabeledSlider(weightSources);
  const heightSlider = LabeledSlider(heightSources);

  const weightVDom$ = weightSlider.DOM;
  const weightValue$ = weightSlider.value;

  const heightVDom$ = heightSlider.DOM;
  const heightValue$ = heightSlider.value;

  const bmi$ = xs.combine(weightValue$, heightValue$)
    .map(([weight, height]) => {
      const heightMeters = height * 0.01;
      const bmi = Math.round(weight / (heightMeters * heightMeters));
      return bmi;
    })
    .remember();

  const vdom$ = xs.combine(bmi$, weightVDom$, heightVDom$)
    .map(([bmi, weightVDom, heightVDom]) =>
      div([
        weightVDom,
        heightVDom,
        h2('BMI is ' + bmi)
      ])
    );

  return {
    DOM: vdom$
  };
}
```

However, this creates a bug. Both labeled sliders change when any slider is moved. Can you see why? Pay attention to the implementation of `LabeledSlider` with this piece of code:

```javascript
function LabeledSlider(sources) {
  // ...

  const newValue$ = domSource
    .select('.slider')
    .events('input')
    .map(ev => ev.target.value);

  // ...
}
```

Suppose we just ran this function for the weight labeled slider. The line `sources.DOM.select('.slider')` **will attempt to select all** `.slider` **elements on the entire DOM tree managed by this app**. This means both the `.slider` in the weight component and the `.slider` in the height component. As a result, the weight component will detect changes to both the height slider and the weight slider, which is a bug.

A component should not leak its output to other components, and it should not be able to detect outputs from other sibling components. In order to keep the nice property of "a component is just a Cycle.js app", we want two properties:

- A component's **sources** are not affected by other components' sources.
- A component's **sinks** do not affect other components' sinks.

In order to achieve these properties, we need to modify the sources when they enter the component, and also modify the sinks when they are returned from the component. To make sources and sinks isolated from influence of other components, we need to introduce a scope for the current component.

For the DOM source and DOM sink, we can use a unique identifier string as namespace for the virtual DOM element. First, we patch the DOM sink, adding a className to the VNodes it emits.

```diff
 function main(sources) {
   // ...

   const weightSlider = LabeledSlider(weightSources);
   const heightSlider = LabeledSlider(heightSources);

   const weightVDom$ = weightSlider.DOM
+    .map(vnode => {
+      vnode.sel += '.weight';
+      return vnode;
+    });
   const weightValue$ = weightSlider.value;

   const heightVDom$ = heightSlider.DOM
+    .map(vnode => {
+      vnode.sel += '.height';
+      return vnode;
+    });
   const heightValue$ = heightSlider.value;

   // ...
 }
```

This will result in the following rendered HTML:

```html
<div class="labeled-slider weight">
  <span class="label">Weight 70kg</span>
  <input class="slider" type="range" min="40" max="150">
</div>
```

For querying user events on these rendered sliders, the `weightSlider` dataflow component should detect user events *only* from the `<div class="labeled-slider weight">` element and its descendants when the stream `sources.DOM.select('.slider').events('input')` is used.

In the context of the labeled slider component, **`sources.DOM.select()` should refer only to the elements that were created by the corresponding DOM sink in that component**.

We can achieve that by narrowing down the DOM source before it is given to the component, using the same className we patched on the sink, like this:

```diff
 function main(sources) {
   // ...
   const weightSources = {
-    DOM: sources.DOM,
+    DOM: sources.DOM.select('.weight'),
     props: weightProps$
   };
   const heightSources = {
-    DOM: sources.DOM,
+    DOM: sources.DOM.select('.height'),
     props: heightProps$
   };

   const weightSlider = LabeledSlider(weightSources);
   const heightSlider = LabeledSlider(heightSources);
   // ...
 }
```

> ### What does `select()` do?
>
> We have used `.select(selector).events(eventType)` many times previously to get a stream emitting DOM events of type `eventType` happening on the `selector` element(s).
>
> In the code above, `sources.DOM` is a so-called "DOM Source", an object with some functions attached that help us query for the correct event stream. We also called `sources.DOM.select(selector)` without `.events(eventType)`, which returns a **new** DOM source, on which we can call again `select()` or `events()`.
>
> `select('.foo').select('.bar').events('click')` returns a stream of click events happening on `'.foo .bar'` elements. In other words, these are all clicks happening on `'.bar'` elements descendants of `'.foo'` elements. The first call, `select('.foo')`, allows us to "narrow down" the scope of the DOM source.

The code we wrote for isolating sources and sinks looks like boilerplate. Ideally we want to avoid manually managing scopes for each component instance using classNames:

```javascript
function main(sources) {
  // ...
  const weightSources = {
    DOM: sources.DOM.select('.weight'), props: weightProps$
  };
  const heightSources = {
    DOM: sources.DOM.select('.height'), props: heightProps$
  };
  // ...
  const weightVDom$ = weightSlider.DOM
    .map(vnode => {
      vnode.sel += '.weight';
      return vnode;
    });
  // ...
  const heightVDom$ = heightSlider.DOM
    .map(vnode => {
      vnode.sel += '.height';
      return vnode;
    });
  // ...
}
```

To avoid repeating code, such as the `.map(vnode => ...)` which patches the VNode, we could extract the functionality into functions: `isolateDOMSink()` and `isolateDOMSource()`.

```diff
 function main(sources) {
   // ...
   const weightSources = {
-    DOM: sources.DOM.select('.weight'), props: weightProps$
+    DOM: isolateDOMSource(sources.DOM, 'weight'), props: weightProps$
   };
   const heightSources = {
-    DOM: sources.DOM.select('.height'), props: heightProps$
+    DOM: isolateDOMSource(sources.DOM, 'height'), props: heightProps$
   };
   // ...
-  const weightVDom$ = weightSlider.DOM
-    .map(vnode => {
-      vnode.sel += '.weight';
-      return vnode;
-    });
+  const weightVDom$ = isolateDOMSink(weightSlider.DOM, 'weight');
   // ...
-  const heightVDom$ = heightSlider.DOM
-    .map(vnode => {
-      vnode.sel += '.height';
-      return vnode;
-    });
+  const heightVDom$ = isolateDOMSink(heightSlider.DOM, 'height');
   // ...
 }
```

Since these are very useful helper functions, they are packaged in Cycle DOM. They are available as static functions under the DOM source: `sources.DOM.isolateSource` and `sources.DOM.isolateSink`. This is how the `main()` function looks like when we use those functions:

```javascript
function main(sources) {
  const weightProps$ = xs.of({
    label: 'Weight', unit: 'kg', min: 40, value: 70, max: 150
  });
  const heightProps$ = xs.of({
    label: 'Height', unit: 'cm', min: 140, value: 170, max: 210
  });

  const {isolateSource, isolateSink} = sources.DOM;

  const weightSources = {
    DOM: isolateSource(sources.DOM, 'weight'), props: weightProps$
  };
  const heightSources = {
    DOM: isolateSource(sources.DOM, 'height'), props: heightProps$
  };

  const weightSlider = LabeledSlider(weightSources);
  const heightSlider = LabeledSlider(heightSources);

  const weightVDom$ = isolateSink(weightSlider.DOM, 'weight');
  const weightValue$ = weightSlider.value;

  const heightVDom$ = isolateSink(heightSlider.DOM, 'height');
  const heightValue$ = heightSlider.value;

  // ...
}
```

The code above shows how we need to manually process the sources and sinks of a child component to make sure each child is run in an isolated context. It would be better, however, if we could just "isolate" a component and make source and sink isolation happen under the hood.

Such is the purpose of [`isolate()`](https://github.com/cyclejs/cyclejs/tree/master/isolate) (`npm install @cycle/isolate`), a helper function which handles calls to `isolateSource` and `isolateSink` for us. `isolate(Component, scope)` takes a dataflow component function `Component` as input, and outputs a dataflow component function which isolates the sources to `scope`, runs `Component`, then isolates its sinks to `scope` as well. Here is a heavily simplified implementation of `isolate()`:

```javascript
function isolate(Component, scope) {
  return function IsolatedComponent(sources) {
    const {isolateSource, isolateSink} = sources.DOM;
    const isolatedDOMSource = isolateSource(sources.DOM, scope);
    const sinks = Component({DOM: isolatedDOMSource});
    const isolatedDOMSink = isolateSink(sinks.DOM, scope);
    return {
      DOM: isolatedDOMSink
    };
  };
}
```

This allows us to simplify the `main()` function with two labeled slider components:

```diff
 function main(sources) {
   const weightProps$ = xs.of({
     label: 'Weight', unit: 'kg', min: 40, value: 70, max: 150
   });
   const heightProps$ = xs.of({
     label: 'Height', unit: 'cm', min: 140, value: 170, max: 210
   });

-  const {isolateSource, isolateSink} = sources.DOM;
   const weightSources = {
-    DOM: isolateSource(sources.DOM, 'weight'), props: weightProps$
+    DOM: sources.DOM, props: weightProps$
   };
   const heightSources = {
-    DOM: isolateSource(sources.DOM, 'height'), props: heightProps$
+    DOM: sources.DOM, props: heightProps$
   };

+  const WeightSlider = isolate(LabeledSlider, 'weight');
+  const HeightSlider = isolate(LabeledSlider, 'height');

-  const weightSlider = LabeledSlider(weightSources);
+  const weightSlider = WeightSlider(weightSources);
-  const heightSlider = LabeledSlider(heightSources);
+  const heightSlider = HeightSlider(heightSources);

-  const weightVDom$ = isolateSink(weightSlider.DOM, 'weight');
+  const weightVDom$ = weightSlider.DOM;
   const weightValue$ = weightSlider.value;

-  const heightVDom$ = isolateSink(heightSlider.DOM, 'height');
+  const heightVDom$ = heightSlider.DOM;
   const heightValue$ = heightSlider.value;

   // ...
 }
```

Notice the line which creates the `WeightSlider` component:

```javascript
const WeightSlider = isolate(LabeledSlider, 'weight');
```

`isolate()` takes a non-isolated component `LabeledSlider` and restricts it to the `'weight'` scope, creating `WeightSlider`. The scope `'weight'` is only used in this line of code, and nowhere else. We can simplify this code a bit more, by making the scope parameter implicit:

```javascript
const WeightSlider = isolate(LabeledSlider);
```

This does the same as previously, except the scope parameter is unique and autogenerated. The scope string itself was irrelevant to us, so we let `isolate()` generate some scope string for us.

> ### Is `isolate()` pure?
>
> If we leave the scope parameter implicit for both weight and height sliders, then the code becomes
>
> `const WeightSlider = isolate(LabeledSlider);`<br />
> `const HeightSlider = isolate(LabeledSlider);`
>
> Because the right-hand side is the same, does this mean `WeightSlider` and `HeightSlider` are the same component? **Certainly not.**
>
> `isolate()` with an implicit scope parameter is **not** referentially transparent. In other words, calling `isolate()` with an implicit scope is "impure". `WeightSlider` and `HeightSlider` are not the same components. Each one has its own unique scope parameter.
>
> On the other hand, when using an explicit scope parameter, then `isolate()` is referentially transparent. In other words, `Foo` and `Fuu` are the same here:
>
> `const Foo = isolate(LabeledSlider, 'myScope');`<br />
> `const Fuu = isolate(LabeledSlider, 'myScope');`
>
> Since Cycle.js follows functional programming techniques, usually most of its API is referentially transparent. `isolate()` is an exception, for convenience. If you want referential transparency everwhere, then provide explicit scope parameters. If you want convenience and you know how `isolate()` works, then use implicit scope parameters.

If we compare our last code with the code we initially started out naïvely for `main()` to make the BMI calculator, the only difference is the use of `isolate()` on child components:

```diff
 function main(sources) {
   const weightProps$ = xs.of({
     label: 'Weight', unit: 'kg', min: 40, value: 70, max: 150
   });
   const heightProps$ = xs.of({
     label: 'Height', unit: 'cm', min: 140, value: 170, max: 210
   });

   const weightSources = {DOM: sources.DOM, props: weightProps$};
   const heightSources = {DOM: sources.DOM, props: heightProps$};

-  const weightSlider =         LabeledSlider(weightSources);
+  const weightSlider = isolate(LabeledSlider)(weightSources);
-  const heightSlider =         LabeledSlider(heightSources);
+  const heightSlider = isolate(LabeledSlider)(heightSources);

   const weightVDom$ = weightSlider.DOM;
   const weightValue$ = weightSlider.value;

   const heightVDom$ = heightSlider.DOM;
   const heightValue$ = heightSlider.value;

   const bmi$ = xs.combine(weightValue$, heightValue$)
     .map(([weight, height]) => {
       const heightMeters = height * 0.01;
       const bmi = Math.round(weight / (heightMeters * heightMeters));
       return bmi;
     })
     .remember();

   const vdom$ = xs.combine(bmi$, weightVDom$, heightVDom$)
    .map(([bmi, weightVDom, heightVDom]) =>
      div([
        weightVDom,
        heightVDom,
        h2('BMI is ' + bmi)
      ])
    );

   return {
     DOM: vdom$
   };
 }
```

The takeaway is: **when creating multiple instances of the same type of component, just remember to `isolate` each.**

<a class="jsbin-embed" href="//jsbin.com/seqehat/embed?output">JS Bin on jsbin.com</a>

> ### Should I call `isolate()` manually?
>
> While it seems that you need to manually call `isolate()` every time you want to instantiate a component, in practice you can automate it.
>
> Instead of exporting the original non-isolated component, like this:
>
> `export function OriginalComponent(sources) {`<br />
> `  // ...`<br />
> `}`<br />
>
> just export a function that calls `isolate()`:
>
> `export function Component(sources) {`<br />
> `  return isolate(OriginalComponent)(sources);`<br />
> `}`<br />
>
> Doing this gives the consumer automatic isolation without having to think about it.

## Recap

To achieve reusability, **any Cycle.js app is simply a function that can be reused as a component in larger Cycle.js app**. Sources and sinks are the interface between the application and the drivers, but they are also the interface between a child component and its parent.

![nested components](img/nested-components.svg)

From a component's perspective, it should make no assumption on what the parent is. The parent could either be the drivers if the component is used as the `main()`, or the parent could be any other component. For this reason, a component should assume its sources contain only data related to itself. Therefore, the sources and sinks of a component must be *isolated*.

Use `isolateSource` and `isolateSink` to separate the execution contexts of sibling components or unrelated components. Use `isolate` to create a component that automatically applies `isolateSource` and `isolateSink`. This way your codebase will be safe against [*collisions*](https://en.wikipedia.org/wiki/Collision_%28computer_science%29), and each component can work as if it would be the only one in the application.

Each driver should define static functions `isolateSource` and `isolateSink`. We only saw those functions implemented for the DOM Driver, but there are other use cases with other drivers where it makes sense to apply the same isolation techniques.

# Drivers

## Plugins for effects

Throughout this documentation site we have extensively used *drivers*. The DOM Driver has been the most common one, but also the HTTP driver was used.

What are drivers and when should you use them? When should you create your own driver, and how do they work? These are a few questions we will address in this chapter.

**Drivers are functions that listen to sink streams (their input), perform imperative side effects, and may return source streams (their output).**

They are meant for encapsulating imperative side effects in JavaScript. The rule of thumb is: whenever you have a JavaScript function such as `doSomething()` which returns nothing, it should be contained in a driver.

Let's study what drivers do by analyzing the most common one: the DOM Driver.

> ### Why the name "driver"?
>
> In Haskell 1.0 Stream I/O, similar in nature to Cycle.js, there is a cyclic interaction between the program's `main` function and Haskell's `os` function. In operating systems, drivers are software interfaces to use some hardware devices, which incur side effects in the external world.
>
> In Cycle.js, one can consider the "operating system" to be the execution environment surrounding your application. Roughly speaking, the DOM, the console, JavaScript and JS APIs assume the role of the operating system for the web. We need *software adapters* to interface with the browser and other environments such as Node.js. Cycle.js drivers are there as adapters between the external world (including the user and the JavaScript execution environment) and the application world built with Cycle.js tools.

## DOM Driver

The DOM Driver is the most important and most common driver in Cycle.js. When building interactive web apps, it is probably the most important tool in Cycle.js. In fact, while Cycle *Run* function is only about 200 lines of code, Cycle *DOM* is at least 4 times larger.

It's main purpose is to be a proxy to the user using the browser. Conceptually we would like to work assuming the existence of a `human()` function, as this diagram reminds us:

![Human computer diagram](img/human-computer-diagram.svg)

However, in practice, we write our `main()` function targeted at a `domDriver()`. For a user interacting with a browser, we only need to make our `main()` interact with the DOM. Whenever we need to show something to the user, we instead show that to the DOM, and the DOM together with the browser shows that to our user. When we need to detect the user's interaction events, we attach event listeners on the DOM, and the DOM will notify us when the user interacts with the browser on the computer.

![Main, DOM Driver, Side Effects](img/main-domdriver-side-effects.svg)

Notice there are two directions of interaction with the external world through the DOM. The *write* effect is the renderization of our Snabbdom VNodes to DOM elements which can be shown on the user's screen. The *read* effect is the detection of DOM events generated by the user manipulating the computer.

The `domDriver()` manages these two effects while allowing them to be interfaced with the `main()`. The *input* to `domDriver()` captures instructions for the *write* effect, and the *read* effect is exposed as the *output* of `domDriver()`. The anatomy of the `domDriver()` function is roughly the following:

```javascript
function domDriver(vdom$) {
  // Use vdom$ as instructions to create DOM elements
  // ...
  return {
    select: function select(selector) {
      // returns an object with two functions: `events()`
      // and `elements()`. Function `events(eventType)`
      // returns the stream of `eventType` DOM events
      // happening on the elements matched by `selector`.
      // Function `elements()` is the stream of DOM
      // elements matching the given `selector`.
    }
  };
}
```

The input `vdom$` is the output from `main()`, and the output of `domDriver()` is the input to `main()`:

```javascript
function main(sources) {
  // Use sources.DOM.select(selector).events(eventType)
  // ...
  // Create vdom$ somehow
  // ...
  return {
    DOM: vdom$
  };
}
```

As a recap:

- `main()`: takes **sources** as input, returns **sinks**
- `domDriver()`: takes **sinks** as input, performs write and read effects, returns **sources**.

## Isolating side effects

Drivers should always be associated with some side effect. As we saw, even though the DOM Driver's main purpose is to represent the user, it has write and read effects.

In JavaScript, nothing stops you from writing your `main()` function with side effects. A simple `console.log()` is already a side effect. However, to keep `main()` pure and reap its benefits like testability and predictability, it is better to encapsulate all side effects in drivers.

Imagine, for instance, a driver for network requests. By isolating the network request side effect, your application's `main()` function can focus on business logic related to the app's behavior, and not on lower-level instructions to interface with external resources. This also allows a simple method for testing network requests: you can replace the actual network driver with a fake network driver. It just needs to be a function that mimics the network driver function, and makes assertions.

Avoid making drivers if they do not have effects to the external world somehow. Especially do not create drivers to contain business logic. This is most likely a code smell.

Drivers should focus solely on being an interface for effects, and usually are libraries that simply enable your Cycle.js app to perform different effects. Sometimes, though, a one-liner driver can be created on the fly instead of being a library, for instance this simple logging driver:

```javascript
run(main, {
  log: msg$ => { msg$.addListener({next: msg => console.log(msg)}) }
});
```

## Read-only and write-only

Most drivers, like the DOM Driver, take *sinks* (to describe a *write*) and return *sources* (to catch *reads*). However, we might have valid cases for write-only drivers and read-only drivers.

For instance, the one-liner `log` driver we just saw above is a write-only driver. Notice how it is a function that does not return any stream, it simply consumes the sink `msg$` it receives.

Other drivers only create source streams that emit events to the `main()`, but don't take in any `sink` from `main()`. An example of such would be a read-only Web Socket driver, drafted below:

```javascript
function WSDriver(/* no sinks */) {
  return xs.create({
    start: listener => {
      this.connection = new WebSocket('ws://localhost:4000');
      connection.onerror = (err) => {
        listener.error(err)
      }
      connection.onmessage = (msg) => {
        listener.next(msg)
      }
    },
    stop: () => {
      this.connection.close();
    },
  });
}
```

## How to make drivers

You should only be reading this section if you have clear intentions to make a driver and expose it as a library (unless it's a one-liner driver). Typically, when writing a Cycle.js app, you do not need to create your own drivers.

Consider first carefully which side effects your driver is responsible for. And can it have both read and write effects?

Once you map out the read/write effects, consider how diverse those can be. Create an empathic API which covers the common cases elegantly.

The **input** to the driver function is expected to be a single stream. This is a practical API for the app developer to use when returning the `sinks` object in `main()`. Notice how the DOM Driver takes a single `vdom$` stream as input, and how sophisticated and expressive VNodes from Snabbdom can be. On the other hand, don't always choose JavaScript objects as the values emitted in the Observable. Use objects when they make sense, and remember to keep the API simple rather than overly-generic. Don't over-engineer.

As a second, optional, argument to the driver function, you can expect `runStreamAdapter`. A "Stream Adapter" is a library that knows how to convert between one specific stream library (like xstream or RxJS) to a generic adapter interface used internally in Cycle.js. This is needed for those cases your driver function needs to return a sophisticated source object which can create arbitrary streams using the same stream library that your application uses. If your app uses `@cycle/xstream-run`, then it uses under the hood `@cycle/xstream-adapter`, which is the argument `runStreamAdapter` given to drivers. If your app uses `@cycle/rxjs-run`, then `runStreamAdapter` is `@cycle/rxjs-adapter`, and so forth. Hence the driver function signature is:

```javascript
function myDriver(sink$, runStreamAdapter /* optional */)
```

The **output** of the driver function can either be a single stream or a *queryable collection* of streams.

In the case of a single stream as output source, depending on how diverse the values emitted by this stream are, you might want to make those values easily filterable (using the xstream or RxJS `filter()` operator). Design an API which makes it easy to filter the stream, keeping in mind what was provided as the sink stream to the driver function.

In some cases it is necessary to output a queryable collection of Observables, instead of a single one. A **queryable collection of Observables** is essentially a JavaScript object with a function used to choose a particular stream based on a parameter, e.g. `get(param)`.

The DOM Driver, for instance, outputs a queryable collection of streams. The collection is in fact lazy: none of the streams outputted by `select(selector).events(eventType)` existed prior to the call of `events()`. This is because we cannot afford creating streams for *all* possible events on *all* elements on the DOM. Take inspiration from the lazy queryable collection of streams from the DOM Driver whenever the output source contains a large (possibly infinite) amount of streams.

You most likely will need `runStreamAdapter` only for queryable collections of streams **and** if you want your driver usable by any other stream library. If you are building your driver only for your own use, then just write the driver using the same stream library that your application uses.

## Example driver

Suppose you have a fake real-time channel API called `Sock`. It is able to connect to a remote peer, send messages, and receive push-based messages. The API for `Sock` is:

```javascript
// Establish a connection to the peer
let sock = new Sock('unique-identifier-of-the-peer');

// Subscribe to messages received from the peer
sock.onReceive(function (msg) {
  console.log('Received message: ' + msg);
});

// Send a single message to the peer
sock.send('Hello world');
```

**How do we build a driver for `Sock`?** We start by identifying the effects. The *write* effect is `sock.send(msg)` and the *read* effect is the listener for received messages. Our `sockDriver(sink)` should take `sink` as instructions to perform the `send(msg)` calls. The output from `sockDriver()` should be `source`, containing all received messages.

Since both input and output should be streams, it's easy to see `sink` in `sockDriver(sink)` should be an stream of outgoing messages to the peer. And conversely, the source should be an stream of incoming messages. This is a draft of our driver function:

```javascript
function sockDriver(outgoing$) {
  outgoing$.addListener({
    next: outgoing => {
      sock.send(outgoing);
    },
    error: () => {},
    complete: () => {},
  });

  return xs.create({
    start: listener => {
      sock.onReceive(function (msg) {
        listener.next(msg);
      });
    },
    stop: () => {},
  });
}
```

The listener of `outgoing$` performs the `send()` side effect, and the stream returned based on `sock.onReceive` takes data from the external world. However, `sockDriver` is assuming `sock` to be available in the closure. As we saw, `sock` needs to be created with a constructor `new Sock()`. To solve this dependency, we need to create a factory that makes `sockDriver()` functions.

```javascript
function makeSockDriver(peerId) {
  let sock = new Sock(peerId);

  function sockDriver(outgoing$) {
    outgoing$.addListener({
      next: outgoing => {
        sock.send(outgoing));
      },
      error: () => {},
      complete: () => {},
    });

    return xs.create({
      start: listener => {
        sock.onReceive(function (msg) {
          listener.next(msg);
        });
      },
      stop: () => {},
    });
  }

  return sockDriver;
}
```

`makeSockDriver(peerId)` creates the `sock` instance, and returns the `sockDriver()` function. We use this in a Cycle.js app as such:

```javascript
function main(sources) {
  const incoming$ = sources.sock;
  // Create outgoing$ (stream of string messages)
  // ...
  return {
    sock: outgoing$
  };
}

run(main, {
  sock: makeSockDriver('B23A79D5-some-unique-id-F2930')
});
```

Notice we have the `peerId` specified when the driver is created in `makeSockDriver(peerId)`. If the `main()` needs to dynamically connect to different peers according to some logic, then we shouldn't use this API anymore. Instead, we need the driver function to take instructions as input, such as "connect to peerId", or "send message to peerId". This is one example of the considerations you should take when designing a driver API.

## Extensibility

Cycle *Core* is a very small framework, and Cycle *DOM*'s Driver is available as an optional plugin for your app. This means it is simple to replace the DOM Driver with any other driver function providing interaction with the user.

You can for instance fork the DOM Driver, adapt it to your preferences, and use it in a Cycle.js app. You can create a driver to interface with sockets. Drivers to perform network requests. Drivers meant for Node.js. Drivers that target other UI trees, such as `<canvas>` or even native mobile UI.

As a framework, it cannot be compared to monoliths which have ruled web development in the recent years. Cycle.js itself is after all just a small tool and a convention to create reactive dialogues with the external world using reactive streams.

  </script>

  <!-- Initializer -->
  <script>
    Flatdoc.run({
      fetcher: function(callback) {
        callback(null, document.getElementById('markdown').innerHTML);
      },
      highlight: function (code, value) {
        return hljs.highlight(value, code).value;
      },
    });
  </script>

</head>
<body role='flatdoc' class="no-literate">

  <div class='header'>
    <div class='left'>
      <h1><a href="/"><img class="logo" src="img/cyclejs_logo.svg" >Cycle.js</a></h1>
      <ul>
        <li><a href='https://github.com/staltz/cycle-onionify'>Documentation</a></li>
        <li><a href='https://github.com/staltz/cycle-onionify/issues'>API reference</a></li>
        <li><a href='https://github.com/staltz/cycle-onionify/issues'>Releases</a></li>
      </ul>
    </div>
    <div class='right'>
      <!-- GitHub buttons: see http://ghbtns.com -->
      <iframe src="http://ghbtns.com/github-btn.html?user=cyclejs&amp;repo=cyclejs&amp;type=watch&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
    </div>
  </div>

  <div class='content-root'>
    <div class='menubar'>
      <div class='menu section' role='flatdoc-menu'></div>
    </div>
    <div role='flatdoc-content' class='content'></div>
  </div>

  <script>
  /* TODO: enable once launched?
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-43862400-3', 'auto');
    ga('send', 'pageview');
  */
  </script>
</body>
</html>